#summary Solving Linear Systems

= Introduction =

Solving linear systems are a fundamental problem in linear algebra.  A linear system is any system than can be expressed in this format:

_A_*_x_ = _b_

where _A_ is m by n, _x_ is n by o, and _b_ is m by o.  Most of the time o=1.  There are numerous ways to solve such system.  Which technique is optimal depends on the size and structure of the matrix. 

In EJML the easiest way to solve a linear system is by calling CommonOps.solve() when using DenseMatrix64 or SimpleMatrix.solve().  LinearSolvers can be used if more knowledge is available about the type of matrix and/or more control is needed over memory.  It is also possible to directly call decomposition algorithms, but this technique is not recommended since it requires much more knowledge about the algorithms and the specific implementation used.

All linear solvers in EJML assume the input system is not singular or nearly singular.  Such systems do not have a single solution and require other techniques to extract a solution.  Just because a solver does not report an error does not mean it did not fail, depending on the algorithm being used.  This is true for virtually all linear algebra libraries.  In fact EJML does a better job of reporting failures than all other libraries tested in [http://code.google.com/p/java-matrix-benchmark/ java matrix benchmark].  Typically if an unreported failure occurs the matrix will contain uncountable elements.  This can be checked by invoking MatrixFeatures.hasUncountable().  A solution can be checked using LinearSolver.quality() too.

= Solving with CommonOps =

The recommended method for quick development and for novice users is calling CommonOps.solve() or if using SimpleMatrix calling SimpleMatrix.solve().  Below are examples of how to solve a linear system:

Using DenseMatrix64F:
{{{
DenseMatrix64F A = new DenseMatrix64F(m,n);
DenseMatrix64F x = new DenseMatrix64F(n,1);
DenseMatrix64F b = new DenseMatrix64F(m,1);

.... code ....

if( !CommonOps.solve(A,b,x) ) {
  throw new IllegalArgument("Singular matrix");
}
}}}

Using SimpleMatrix:
{{{
SimpleMatrix A = new SimpleMatrix(m,n);
SimpleMatrix b = new SimpleMatrix(m,1);

.... code ...

try {
  SimpleMatrix x = A.solve(b);
} catch ( SingularMatrixException e ) {
  throw new IllegalArgument("Singular matrix");
}

}}}

Note how the above code samples check to see if any errors occurred while trying to solve the system.  As previously mentioned it is possible for no error to be reported and yet have a bad solution.

= Solving with LinearSolver =

While easy to use solve() has limited functionality and can be inefficient.  An alternative to working direction with matrix decompositions is to use LinearSolvers. The LinearSolver interface is designed to be easy to use and to provide most of the power that using the decompositions directly would provide.  Below is a summary of the interface:
{{{
public interface LinearSolver {

    public boolean setA( DenseMatrix64F A );

    public DenseMatrix64F getA();

    public double quality();

    public void solve( DenseMatrix64F B , DenseMatrix64F X );

    public void invert( DenseMatrix64F A_inv );
}
}}}

There are several different implementations of LinearSolver for different types of matrices.  A new LinearSolver should be created by invoking static functions inside of LinearSolverFactory.  LinearSolverFactory will select the best algorithm and is will be updated as EJML evolves.

Two steps are required to solve a system with a LinearSolver, as is shown below:
{{{
LinearSolver solver = LinearSolverFactory.leastSquares();

if( !solver.setA(A) ) {
  throw new IllegalArgument("Singular matrix");
}

solver.solve(b,x);
}}}

Additional functions included in LinearSolver are:

  * invert()
    * Will invert a matrix more efficiently than solve() can.
  * quality()
    * Returns a positive number whose magnitude indicates if a solution was generated from a numerically stable system.

Linear solver can also solve for other 'b' matrices using the same 'A'.  As noted earlier solve() can return true and still return garbage results.  If not sure a call to quality() can be used to validate the solution.

== AdjustableLinearSolver ==

In situations where rows from the linear system are added or removed (see [PolynomialFitExample]) an AdjustableLinearSolver can be used to efficiently resolve the modified system.  AdjustableLinearSolver is an extension of LinearSolver that adds addRowToA() and removeRowFromA().  These functions add and remove rows from A respectively.  After being involved the solution can be recomputed by calling solve() again.

{{{
AdjustableLinearSolver solver = LinearSolverFactory.adjustable();

if( !solver.setA(A) ) {
  throw new IllegalArgument("Singular matrix");
}

solver.solve(b,x);

// add a row
double row[] = new double[N];

... code ...

solver.addRowToA(row,2);

.... adjust b and x ....

solver.solve(b,x); 

// remove a row
solver.removeRowFromA(7);

.... adjust b and x ....


solver.solve(b,x);
}}}