#summary Solving Linear Systems

= Introduction =

Solving linear systems are a fundamental problem in linear algebra.  A linear system is any system than can be expressed in this format:

_A_*_x_ = _b_

where _A_ is m by n, _x_ is n by 1, and _b_ is m by 1.  There are numerous ways to solve such system.  Which technique is optimal depends on the size and structure of the matrix. 

In EJML the easiest way to solve a linear system is by calling CommonOps.solve() when using DenseMatrix64 or SimpleMatrix.solve().  LinearSolvers can be used if more knowledge is available about the type of matrix and/or more control is needed over memory.  It is also possible to directly call decomposition algorithms, but this technique is not recommended since it more error prone and is not guaranteed to work in future releases.

All linear solvers in EJML assume the input system is not singular or nearly singular.  Such systems do not have a single solution and require other techniques to extract a solution.  Just because a solver does not report an error does not mean it did not fail, depending on the algorithm being used.  This is true for virtually all linear algebra libraries.  In fact EJML does a better job of reporting failures than all other libraries tested in [http://code.google.com/p/java-matrix-benchmark/ java matrix benchmark].  Typically if an unreported failure occurs the matrix will contain uncountable elements.  This can be checked by invoking MatrixFeatures.hasUncountable().

= Solving with CommonOps =

The recommended method for quick development and for novice users is calling CommonOps.solve() or SimpleMatrix.solve().  SimpleMatrix.solve() is a wrapper around CommonOps.solve() and has nearly the same behavior.  Below are examples of how to solve a linear system:

Using DenseMatrix64F:
{{{
DenseMatrix64F A = new DenseMatrix64F(m,n);
DenseMatrix64F x = new DenseMatrix64F(n,1);
DenseMatrix64F b = new DenseMatrix64F(m,1);

.... code ....

if( !CommonOps.solve(A,b,x) ) {
  throw new IllegalArgument("Singular matrix");
}
}}}

Using SimpleMatrix:
{{{
SimpleMatrix A = new SimpleMatrix(m,n);
SimpleMatrix b = new SimpleMatrix(m,1);

.... code ...

try {
  SimpleMatrix x = A.solve(b);
} catch ( SingularMatrixException e ) {
  throw new IllegalArgument("Singular matrix");
}

}}}

Note how the above code samples check to see if any errors occurred while trying to solve the system.  As previously mentioned it is possible for no error to be reported and yet

= Solving with LinearSolver =

LinearSolver provide an easy to use interface but almost all the power of calling algorithms directly.  Which type of LinearSolver should be used depends on the structure of the matrix.  A new LinearSolver should be created by invoking static functions inside of LinearSolverFactory.  LinearSolverFactory will select the best algorithm and is will be updated as EJML evolves.

Two steps are required to solve a system with a LinearSolver, as is shown below:
{{{
LinearSolver solver = LinearSolverFactory.leastSquares();

if( !solver.setA(A) ) {
  throw new IllegalArgument("Singular matrix");
}

solver.solve(b,x);
}}}

== AdjustableLinearSolver ==

In situations where rows from the linear system are added or removed (see [PolynomialFitExample]) an AdjustableLinearSolver can be used to efficiently resolve the modified system.  AdjustableLinearSolver is an extension of LinearSolver that adds addRowToA() and removeRowFromA().  These functions add and remove rows from A respectively.  After being involved the solution can be recomputed by calling solve() again.

{{{
AdjustableLinearSolver solver = LinearSolverFactory.adjustable();

if( !solver.setA(A) ) {
  throw new IllegalArgument("Singular matrix");
}

solver.solve(b,x);

// add a row
double row[] = new double[N];

... code ...

solver.addRowToA(row,2);

.... adjust b and x ....

solver.solve(b,x); 

// remove a row
solver.removeRowFromA(7);

.... adjust b and x ....


solver.solve(b,x);
}}}