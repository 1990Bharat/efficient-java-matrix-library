#summary How to perform common matrix decompositions in EJML

= Introduction =

In linear algebra a matrix decomposition is often used as an intermediate step when solving a problem.  They allow a more complex problem to be reformulated into a more simplistic problem or provide insight into the structure of a matrix.  EJML provides several different matrix decompositions, such as:

 * LU
 * Cholesky
 * QR
 * Singular Value Decomposition (SVD)
 * Eigen Value Decomposition (EVD)

Additional decompositions are provided, but they are primarily used internally and have less common usage.  Specialized helper functions are provided for SVD and EVD.

= Solving Linear Systems =

Decompositions such as LU and QR are most commonly used to solve a linear system.  A common mistake when solving linear systems in EJML is to directly decompose  the matrix instead of using a LinearSolver.  LinearSolvers significantly simplify the process of solving a linear system and will automatically be updated as new algorithms are added.

For more information on LinearSolvers see the wikipage at [SolvingLinearSystems].

= SimpleMatrix =

SimpleMatrix has easy to an use interface built in for SVD and EVD:
{{{
SimpleMatrix.SVD svd = A.svd();
SimpleMatrix.EVD evd = A.eig();

SimpleMatrix U = svd.getU();
}}}
To perform other decompositions the internal DenseMatrix64F needs to be extracted and processed using a decomposition from DecompositionOps.


= DecompositionOps =

The best way to create a matrix decomposition is by using DecompositionOps.  It is not uncommon for there to be multiple algorithms in EJML that perform the same decomposition.  These are most often optimized for different input matrix size or specialized cases.  Unless you really know what you are doing, read the JavaDoc and go through the code, chances are you will pick the wrong algorithm.

{{{
public interface DecompositionInterface {
    /**
     * Computes and stores internally the decomposition of the provided matrix.
     *
     * @param orig The matrix which is being decomposed.  Not modified.
     * @return Returns if it was able to decompose the matrix.
     */
    public boolean decompose( DenseMatrix64F orig );
}
}}}

Most decompositions in EJML implement DecompositionInterface.  To decompose the matrix simply call decompose(A), where A is the matrix being decomposed.  It returns true if there was no error while decomposing and false otherwise.  While in general you can trust the results if true is returned some algorithms can have faults that are not reported.  This is true for all linear algebra libraries.

Below is an example of how to compute the SVD of a matrix:
{{{
    void decompositionExample( DenseMatrix64F A ) {
        SingularValueDecomposition svd = DecompositionOps.svd();

        if( !svd.decompose(A) )
            throw new RuntimeException("Decomposition failed");

        DenseMatrix64F U = svd.getU(false);
        DenseMatrix64F W = svd.getW(null);
        DenseMatrix64F V = svd.getV(false);

    }
}}}
Note how it checks the returned value from decompose.

In addition DecompositionOps provides functions for computing the quality of a decomposition.  Being able measure the decomposition's quality is an important way to validate its correctness.  It works by "reconstructing" the original matrix then computing the difference between the reconstruction and the original.  Smaller the quality is the better the decomposition is. With an ideal value of being around 1e-15 in most cases.

= Helper Functions for SVD and EVD =

Two classes SingularOps and EigenOps have been provided for extracting useful information from these decompositions or to provide highly specialized ways of computing the decompositions.  Below is a list of more common uses of these functions:

SingularOps
  * descendingOrder()
    * In EJML the ordering of the returned singular values is not in general guaranteed.  This function will reorder the U,W,V matrices such that the singular values are in the standard largest to smallest ordering.  
  * nullSpace()
    * Computes the null space from the provided decomposition.
  * rank()
    * Returns the matrix's rank.
  * nullity()
    * Returns the matrix's nullity.

EigenOps
  * decompositionGeneral()
    * Creates an EVD that can be used on any input matrix.
  * decompositionSymmetric()
    * Creates an EVD which can only be used on symmetric input matrices.
  * createMatrixD() and createMatrixV()
    * Reformats the results such that two matrices (D and V) that contain the eigenvalues and eigenvectors respectively.
  * quality()
    * Can be used to check to see if the returned EVD is accurate or not.